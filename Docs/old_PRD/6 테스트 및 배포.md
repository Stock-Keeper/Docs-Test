# 6. 테스트 및 배포

### 6-1. 테스트 전략

- **테스트 피라미드**:
    - 단위 테스트 (Unit Test): `70% - 가장 많은 비중`
    - 통합 테스트 (Integration Test): `20%`
    - E2E 테스트 (End-to-End): `10%`
- **테스트 커버리지 목표**:
    - Phase 1: `코어 비즈니스 로직 70% 이상`
    - Phase 2: `전체 코드 80% 이상`
    - Phase 3: `90% 이상 (크리티컬 경로 100%)`

### 6-2. 단위 테스트 (Unit Test)

- **Backend 테스트**:
    - 도구: `JUnit 5, Mockito, AssertJ`
    - 대상:
        - 비즈니스 로직: `리밸런싱 계산, 비율 계산, 매수/매도 수량 제안`
        - 유틸리티 함수: `데이터 변환, 검증 로직`
        - Service 레이어: `포트폴리오/종목 CRUD, 한투 API 호출 래퍼`
    - 예시:
        - `calculateRebalancing()` 함수의 다양한 입력값에 대한 출력 검증
        - `validateStockQuantity()` 함수의 경계값 테스트
- **Frontend 테스트**:
    - 도구: `Jest, React Native Testing Library`
    - 대상:
        - 컴포넌트 렌더링: `버튼, 입력 필드, 리스트`
        - 상태 관리 로직: `포트폴리오 추가/삭제, 종목 수량 변경`
        - 유틸리티 함수: `금액 포맷팅, 비율 계산`
    - 예시:
        - `PortfolioCard` 컴포넌트가 props를 올바르게 표시하는지 검증
        - `formatCurrency(1234567)` 함수가 '1,234,567원'을 반환하는지 검증

### 6-3. 통합 테스트 (Integration Test)

- **Backend 통합 테스트**:
    - 도구: `Spring Boot Test, TestContainers (MySQL 컨테이너)`
    - 대상:
        - API 엔드포인트: `포트폴리오 생성 → 종목 추가 → 리밸런싱 조회 플로우`
        - DB 연동: `JPA Repository 쿼리 검증`
        - 외부 API 연동: `한투 API Mock 서버 또는 Sandbox 환경`
    - 예시:
        - POST `/portfolios` → POST `/portfolios/{id}/stocks` → GET `/portfolios/{id}/rebalancing` 전체 플로우 테스트
        - 포트폴리오 삭제 시 연관된 종목도 함께 삭제되는지 검증 (Cascade)
- **Frontend 통합 테스트**:
    - 도구: `React Native Testing Library, MSW (Mock Service Worker)`
    - 대상:
        - 화면 간 네비게이션: `로그인 → 포트폴리오 목록 → 상세 화면`
        - API 호출 및 상태 업데이트: `종목 추가 후 목록 갱신`
    - 예시:
        - 종목 추가 버튼 클릭 → 검색 화면 이동 → 종목 선택 → 수량 입력 → 저장 후 목록 갱신 확인

### 6-4. E2E 테스트 (End-to-End Test)

- **테스트 도구**:
    - 모바일: `Detox (React Native 전용) 또는 Appium`
    - 대안: `Maestro (간단한 UI 자동화 도구)`
- **테스트 시나리오**:
    1. **회원가입 및 로그인**:
        - Google 로그인 → 프로필 입력 → 홈 화면 진입
    2. **포트폴리오 생성 및 종목 추가**:
        - 포트폴리오 추가 → 종목 검색 → 수량 입력 → 저장 → 목록 확인
    3. **리밸런싱 분석**:
        - 포트폴리오 선택 → 리밸런싱 버튼 → 제안 확인
    4. **알림 설정**:
        - 설정 화면 → 알림 ON → 주기 선택 → 저장
    5. **포트폴리오 삭제**:
        - 포트폴리오 선택 → 삭제 버튼 → 확인 다이얼로그 → 삭제 완료
- **실행 주기**:
    - Phase 1: `배포 전 수동 실행`
    - Phase 2: `CI/CD 파이프라인에 통합, PR 머지 전 자동 실행`

### 6-5. 테스트 자동화

- **CI/CD 파이프라인 통합**:
    - 도구: `GitHub Actions`
    - 트리거:
        - Pull Request 생성/업데이트 시
        - main/develop 브랜치 Push 시
    - 실행 단계:
        1. 코드 체크아웃
        2. 의존성 설치
        3. 린트 검사 (ESLint, Checkstyle)
        4. 단위 테스트 실행
        5. 통합 테스트 실행
        6. 테스트 커버리지 리포트 생성
        7. E2E 테스트 실행 (선택적)
- **테스트 실패 시 처리**:
    - PR 머지 차단
    - Slack/Discord 알림
    - 실패 원인 로그 저장

### 6-6. 배포 환경

- **환경 구성**:
    - **개발 환경 (Development)**:
        - 용도: `개발자 로컬 테스트`
        - DB: `로컬 MySQL 또는 Docker`
        - API: `한투 API Sandbox (테스트 환경)`
    - **스테이징 환경 (Staging)**:
        - 용도: `QA 테스트, 배포 전 최종 검증`
        - 서버: `AWS EC2 t3.micro 1대`
        - DB: `AWS RDS MySQL (개발용 인스턴스)`
        - 도메인: [`staging-api.yourapp.com`](http://staging-api.yourapp.com)
        - 특징: `프로덕션과 동일한 환경, 테스트 데이터 사용`
    - **프로덕션 환경 (Production)**:
        - 용도: `실제 사용자 서비스`
        - 서버: `AWS EC2 t3.small 이상`
        - DB: `AWS RDS MySQL (프로덕션 인스턴스)`
        - 도메인: [`api.yourapp.com`](http://api.yourapp.com)
        - 특징: `실제 데이터, 백업 활성화, 모니터링 강화`

### 6-7. 배포 전략

- **배포 방식**:
    - **Backend**:
        - Phase 1: `수동 배포 (SSH + Git Pull + 재시작)`
        - Phase 2: `GitHub Actions 자동 배포 (Zero-downtime 배포)`
        - Phase 3: `Blue-Green 배포 또는 Canary 배포`
    - **Frontend (모바일 앱)**:
        - 내부 테스트: `Expo Go 또는 TestFlight (iOS) / Firebase App Distribution (Android)`
        - 공개 배포: `App Store (iOS) / Google Play (Android)`
        - OTA 업데이트: `Expo Updates 또는 CodePush (긴급 패치용)`
- **배포 체크리스트**:
    - [ ]  테스트 통과 확인 (단위/통합/E2E)
    - [ ]  코드 리뷰 완료
    - [ ]  DB 마이그레이션 스크립트 준비 (있는 경우)
    - [ ]  환경 변수 확인 (API Key, Secret)
    - [ ]  백업 완료 (프로덕션 DB)
    - [ ]  배포 공지 (사용자 공지, 점검 시간)
    - [ ]  롤백 계획 수립
    - [ ]  배포 후 헬스 체크

### 6-8. CI/CD 파이프라인

- **GitHub Actions Workflow 예시**:
    
    ```yaml
    name: CI/CD Pipeline
    on:
      push:
        branches: [main, develop]
      pull_request:
        branches: [main, develop]
    
    jobs:
      test:
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v3
          - name: Set up JDK 17
            uses: actions/setup-java@v3
            with:
              java-version: '17'
          - name: Run Tests
            run: ./gradlew test
          - name: Upload Coverage
            uses: codecov/codecov-action@v3
    
      deploy:
        needs: test
        if: github.ref == 'refs/heads/main'
        runs-on: ubuntu-latest
        steps:
          - name: Deploy to Production
            run: |
              ssh user@server 'cd /app && git pull && ./[deploy.sh](http://deploy.sh)'
    ```
    
- **주요 단계**:
    1. 코드 체크아웃
    2. 환경 설정 (JDK, Node.js)
    3. 의존성 설치
    4. 테스트 실행
    5. 빌드 (JAR 파일 생성)
    6. 배포 (SSH 또는 AWS CodeDeploy)

### 6-9. 모니터링 및 로그 관리

- **로그 수집**:
    - Backend:
        - 로그 레벨: `ERROR, WARN, INFO, DEBUG`
        - 로그 포맷: `JSON 형식 (시간, 레벨, 메시지, 사용자 ID, 요청 ID)`
        - 저장 위치: `AWS CloudWatch Logs`
    - Frontend:
        - 크래시 리포트: `Firebase Crashlytics`
        - 에러 로그: `Sentry (선택적)`
- **에러 추적**:
    - 도구: `Sentry 또는 Firebase Crashlytics`
    - 알림:
        - 크리티컬 에러: `즉시 Slack/Discord 알림`
        - 일반 에러: `일일 요약 리포트`
- **성능 모니터링**:
    - 도구: `AWS CloudWatch, New Relic (Phase 2), DataDog (Phase 3)`
    - 지표:
        - API 응답 시간 (P50, P95, P99)
        - 요청 처리량 (RPS)
        - 에러율 (4xx, 5xx)
        - 서버 리소스 (CPU, 메모리, 디스크)
- **대시보드**:
    - Phase 1: `CloudWatch 기본 대시보드`
    - Phase 2: `Grafana 커스텀 대시보드 (선택적)`

### 6-10. 롤백 및 장애 대응

- **롤백 전략**:
    - **Backend**:
        - Git 이전 커밋으로 롤백: `git reset --hard <commit-hash> && ./[deploy.sh](http://deploy.sh)`
        - DB 롤백: `최근 백업으로 복구 (Point-in-Time Recovery)`
    - **Frontend**:
        - 앱 스토어: `이전 버전 재배포 (승인 필요, 시간 소요)`
        - OTA 업데이트: `이전 버전으로 즉시 롤백 가능`
- **장애 대응 프로세스**:
    1. **장애 감지**:
        - 모니터링 알림
        - 사용자 신고
        - 헬스 체크 실패
    2. **긴급 조치**:
        - 장애 원인 파악 (로그 확인)
        - 즉시 롤백 (가능한 경우)
        - 서비스 일시 중단 (심각한 경우)
    3. **사용자 공지**:
        - 앱 내 공지
        - 푸시 알림 (선택적)
        - SNS/웹사이트 공지
    4. **원인 분석 및 해결**:
        - 근본 원인 분석 (RCA)
        - 핫픽스 배포
        - 재발 방지 대책 수립
- **장애 대응 시간 목표**:
    - 감지: `5분 이내`
    - 대응 시작: `15분 이내`
    - 복구: `1시간 이내 (목표)`

### 6-11. 베타 테스트 및 출시 계획

- **베타 테스트**:
    - **클로즈드 베타 (Closed Beta)**:
        - 기간: `2주 (Phase 1 개발 완료 후)`
        - 대상: `팀원, 지인, 초대된 사용자 (20~50명)`
        - 목적: `주요 버그 발견, 사용성 테스트, 피드백 수집`
        - 배포: `TestFlight (iOS), Firebase App Distribution (Android)`
    - **오픈 베타 (Open Beta)** (선택적):
        - 기간: `1주`
        - 대상: `공개 모집 (100~200명)`
        - 목적: `대규모 트래픽 테스트, 다양한 기기 호환성 확인`
- **정식 출시**:
    - 출시 전 체크리스트:
        - [ ]  베타 테스트 피드백 반영
        - [ ]  앱 스토어 스크린샷 및 설명 준비
        - [ ]  개인정보 처리방침 공개
        - [ ]  앱 스토어 심사 통과
        - [ ]  서버 용량 확인 및 스케일링 준비
        - [ ]  마케팅 자료 준비 (홍보 문구, 블로그 포스트 등)
    - 출시 후 모니터링:
        - 첫 24시간: `실시간 모니터링 (크래시, 에러율, 성능)`
        - 첫 1주일: `일일 리포트 검토, 사용자 피드백 수집`
        - 첫 1개월: `주간 분석, 개선사항 우선순위 결정`

### 6-12. 팀 논의 필요 사항

- [ ]  E2E 테스트 도구 선택 (Detox vs Appium vs Maestro)
- [ ]  테스트 커버리지 목표 최종 결정 (70% vs 80%)
- [ ]  스테이징 환경 구축 시점 (Phase 1 vs Phase 2)
- [ ]  배포 자동화 우선순위 (Backend 먼저 vs Frontend 먼저)
- [ ]  에러 추적 도구 예산 (Sentry 유료 vs Firebase Crashlytics 무료)
- [ ]  베타 테스트 기간 및 모집 방법
- [ ]  정식 출시 목표 일정 (Phase 1 완료 후 언제?)