# 구현 계획: [기능명]

**상태**: 🔄 진행 중
**시작일**: YYYY-MM-DD
**최종 수정일**: YYYY-MM-DD
**예상 완료일**: YYYY-MM-DD

---

**⚠️ 중요 지침**: 각 단계를 완료한 후:

1. ✅ 완료된 작업 체크박스 체크
2. 🧪 모든 품질 게이트 검증 명령어 실행
3. ⚠️ 모든 품질 게이트 항목이 통과하는지 확인
4. 📅 위 "최종 수정일" 업데이트
5. 📝 참고 섹션에 교훈 기록
6. ➡️ 그 후에만 다음 단계로 진행

⛔ **품질 게이트를 건너뛰거나 실패한 항목이 있는 상태로 진행하지 마세요**

---

## 📋 개요

### 기능 설명

[이 기능이 무엇을 하며 왜 필요한지]

### 성공 기준

- [ ] 기준 1
- [ ] 기준 2
- [ ] 기준 3

### 사용자 영향

[사용자에게 어떤 이점을 주거나 제품을 어떻게 개선하는지]

---

## 🏗️ 아키텍처 결정사항

| 결정 | 근거 | 트레이드오프 |
|------|------|--------------|
| [결정 1] | [이 접근 방식을 선택한 이유] | [포기하는 것] |
| [결정 2] | [이 접근 방식을 선택한 이유] | [포기하는 것] |

---

## 📦 의존성

### 시작 전 필요사항

- [ ] 의존성 1: [설명]
- [ ] 의존성 2: [설명]

### 외부 의존성

- 패키지/라이브러리 1: 버전 X.Y.Z
- 패키지/라이브러리 2: 버전 X.Y.Z

---

## 🧪 테스트 전략

### 테스트 접근 방식

**TDD 원칙**: 테스트를 먼저 작성하고, 이를 통과시키기 위해 구현

### 이 기능을 위한 테스트 피라미드

| 테스트 유형 | 커버리지 목표 | 목적 |
|-------------|---------------|------|
| **단위 테스트 (Unit)** | 80% 이상 | 비즈니스 로직, 모델, 핵심 알고리즘 |
| **통합 테스트 (Integration)** | 핵심 경로 | 컴포넌트 상호작용, 데이터 흐름 |
| **E2E 테스트** | 주요 사용자 흐름 | 전체 시스템 동작 검증 |

### 테스트 파일 구조

```
test/
├── unit/
│   ├── [domain/business_logic]/
│   └── [data/models]/
├── integration/
│   └── [feature_name]/
└── e2e/
    └── [user_flows]/
```

### 단계별 커버리지 요구사항

- **단계 1 (기초)**: 핵심 모델/엔티티에 대한 단위 테스트 (80% 이상)
- **단계 2 (비즈니스 로직)**: 로직 + 리포지토리 테스트 (80% 이상)
- **단계 3 (통합)**: 컴포넌트 통합 테스트 (70% 이상)
- **단계 4 (E2E)**: 엔드 투 엔드 사용자 흐름 테스트 (1개 이상의 핵심 경로)

### 테스트 네이밍 규칙

프로젝트의 테스트 프레임워크 규칙을 따르세요:

```
// 예시 구조 (프레임워크에 맞게 조정):
describe/group: 기능 또는 컴포넌트 이름
  test/it: 테스트되는 구체적인 동작
    // Arrange → Act → Assert 패턴
```

---

## 🚀 구현 단계

### 단계 1: [기초 단계명]

**목표**: [이 단계가 제공하는 구체적이고 작동하는 기능]
**예상 시간**: X 시간
**상태**: ⏳ 대기 | 🔄 진행 중 | ✅ 완료

#### 작업

**🔴 RED: 실패하는 테스트 먼저 작성**

- [ ] **Test 1.1**: [구체적인 기능]에 대한 단위 테스트 작성
  - 파일: `test/unit/[feature]/[component]_test.*`
  - 예상: 기능이 아직 없으므로 테스트 실패 (Red)
  - 상세: 다음을 커버하는 테스트 케이스:
    - 해피 패스(Happy path) 시나리오
    - 엣지 케이스
    - 에러 조건

- [ ] **Test 1.2**: [컴포넌트 상호작용]에 대한 통합 테스트 작성
  - 파일: `test/integration/[feature]_test.*`
  - 예상: 통합이 아직 없으므로 테스트 실패 (Red)
  - 상세: [컴포넌트 목록] 간의 상호작용 테스트

**🟢 GREEN: 테스트를 통과시키기 위한 구현**

- [ ] **Task 1.3**: [컴포넌트/모듈] 구현
  - 파일: `src/[layer]/[component].*`
  - 목표: 최소한의 코드로 Test 1.1 통과
  - 상세: [구현 노트]

- [ ] **Task 1.4**: [통합/글루 코드] 구현
  - 파일: `src/[layer]/[integration].*`
  - 목표: Test 1.2 통과
  - 상세: [구현 노트]

**🔵 REFACTOR: 코드 정리**

- [ ] **Task 1.5**: 코드 품질을 위한 리팩터링
  - 파일: 이 단계의 모든 새 코드 검토
  - 목표: 테스트를 깨뜨리지 않고 설계 개선
  - 체크리스트:
    - [ ] 중복 제거 (DRY 원칙)
    - [ ] 네이밍 명확성 개선
    - [ ] 재사용 가능한 컴포넌트 추출
    - [ ] 인라인 문서(주석) 추가
    - [ ] 필요 시 성능 최적화

#### 품질 게이트 ✋

**⚠️ STOP: 모든 항목이 통과할 때까지 단계 2로 진행하지 마세요**

**TDD 준수** (중요):

- [ ] **Red 단계**: 테스트를 먼저 작성했고 초기에 실패했음
- [ ] **Green 단계**: 테스트를 통과시키기 위해 프로덕션 코드를 작성했음
- [ ] **Refactor 단계**: 테스트가 통과하는 상태에서 코드를 개선했음
- [ ] **커버리지 확인**: 테스트 커버리지가 요구사항을 충족함

  ```bash
  # 예시 명령어 (테스트 프레임워크에 맞게 조정):
  # npm test -- --coverage
  # pytest --cov=src --cov-report=html
  # dotnet test /p:CollectCoverage=true
  # go test -cover ./...

  [프로젝트의 커버리지 명령어]
  ```

**빌드 및 테스트**:

- [ ] **빌드**: 프로젝트가 오류 없이 빌드/컴파일됨
- [ ] **모든 테스트 통과**: 100% 테스트 통과 (건너뛴 테스트 없음)
- [ ] **테스트 성능**: 테스트 스위트가 허용 가능한 시간 내에 완료됨
- [ ] **플래키 테스트 없음**: 테스트가 일관되게 통과함 (3회 이상 실행)

**코드 품질**:

- [ ] **린팅**: 린팅 오류나 경고 없음
- [ ] **포맷팅**: 프로젝트 표준에 따라 코드 포맷팅됨
- [ ] **타입 안전성**: 타입 체커 통과 (해당되는 경우)
- [ ] **정적 분석**: 정적 분석 도구에서 중요 이슈 없음

**보안 및 성능**:

- [ ] **의존성**: 알려진 보안 취약점 없음
- [ ] **성능**: 성능 회귀 없음
- [ ] **메모리**: 메모리 누수나 리소스 문제 없음
- [ ] **에러 처리**: 적절한 에러 처리 구현됨

**문서화**:

- [ ] **코드 주석**: 복잡한 로직 문서화됨
- [ ] **API 문서**: 공개 인터페이스 문서화됨
- [ ] **README**: 필요 시 사용 지침 업데이트됨

**수동 테스트**:

- [ ] **기능성**: 기능이 예상대로 작동함
- [ ] **엣지 케이스**: 경계 조건 테스트됨
- [ ] **에러 상태**: 에러 처리 검증됨

**검증 명령어** (프로젝트에 맞게 커스터마이징):

```bash
# 테스트 명령어
[테스트 러너 명령어]

# 커버리지 확인
[커버리지 명령어]

# 코드 품질
[린터 명령어]
[포맷터 확인 명령어]
[타입 체커 명령어]

# 빌드 검증
[빌드 명령어]

# 보안 감사
[의존성 감사 명령어]

# 생태계별 예시:
# JavaScript/TypeScript: npm test && npm run lint && npm run type-check
# Python: pytest && black --check . && mypy .
# Java: mvn test && mvn checkstyle:check
# Go: go test ./... && golangci-lint run
# .NET: dotnet test && dotnet format --verify-no-changes
# Ruby: bundle exec rspec && rubocop
# Rust: cargo test && cargo clippy
```

**수동 테스트 체크리스트**:

- [ ] 테스트 케이스 1: [검증할 구체적인 시나리오]
- [ ] 테스트 케이스 2: [검증할 엣지 케이스]
- [ ] 테스트 케이스 3: [검증할 에러 처리]

---

### 단계 2: [핵심 기능 단계명]

**목표**: [구체적인 산출물]
**예상 시간**: X 시간
**상태**: ⏳ 대기 | 🔄 진행 중 | ✅ 완료

#### 작업

**🔴 RED: 실패하는 테스트 먼저 작성**

- [ ] **Test 2.1**: [구체적인 기능]에 대한 단위 테스트 작성
  - 파일: `test/unit/[feature]/[component]_test.*`
  - 예상: 기능이 아직 없으므로 테스트 실패 (Red)
  - 상세: 다음을 커버하는 테스트 케이스:
    - 해피 패스 시나리오
    - 엣지 케이스
    - 에러 조건

- [ ] **Test 2.2**: [컴포넌트 상호작용]에 대한 통합 테스트 작성
  - 파일: `test/integration/[feature]_test.*`
  - 예상: 통합이 아직 없으므로 테스트 실패 (Red)
  - 상세: [컴포넌트 목록] 간의 상호작용 테스트

**🟢 GREEN: 테스트를 통과시키기 위한 구현**

- [ ] **Task 2.3**: [컴포넌트/모듈] 구현
  - 파일: `src/[layer]/[component].*`
  - 목표: 최소한의 코드로 Test 2.1 통과
  - 상세: [구현 노트]

- [ ] **Task 2.4**: [통합/글루 코드] 구현
  - 파일: `src/[layer]/[integration].*`
  - 목표: Test 2.2 통과
  - 상세: [구현 노트]

**🔵 REFACTOR: 코드 정리**

- [ ] **Task 2.5**: 코드 품질을 위한 리팩터링
  - 파일: 이 단계의 모든 새 코드 검토
  - 목표: 테스트를 깨뜨리지 않고 설계 개선
  - 체크리스트:
    - [ ] 중복 제거 (DRY 원칙)
    - [ ] 네이밍 명확성 개선
    - [ ] 재사용 가능한 컴포넌트 추출
    - [ ] 인라인 문서 추가
    - [ ] 필요 시 성능 최적화

#### 품질 게이트 ✋

**⚠️ STOP: 모든 항목이 통과할 때까지 단계 3으로 진행하지 마세요**

**TDD 준수** (중요):

- [ ] **Red 단계**: 테스트를 먼저 작성했고 초기에 실패했음
- [ ] **Green 단계**: 테스트를 통과시키기 위해 프로덕션 코드를 작성했음
- [ ] **Refactor 단계**: 테스트가 통과하는 상태에서 코드를 개선했음
- [ ] **커버리지 확인**: 테스트 커버리지가 요구사항을 충족함

**빌드 및 테스트**:

- [ ] **빌드**: 프로젝트가 오류 없이 빌드/컴파일됨
- [ ] **모든 테스트 통과**: 100% 테스트 통과 (건너뛴 테스트 없음)
- [ ] **테스트 성능**: 테스트 스위트가 허용 가능한 시간 내에 완료됨
- [ ] **플래키 테스트 없음**: 테스트가 일관되게 통과함 (3회 이상 실행)

**코드 품질**:

- [ ] **린팅**: 린팅 오류나 경고 없음
- [ ] **포맷팅**: 프로젝트 표준에 따라 코드 포맷팅됨
- [ ] **타입 안전성**: 타입 체커 통과 (해당되는 경우)
- [ ] **정적 분석**: 정적 분석 도구에서 중요 이슈 없음

**보안 및 성능**:

- [ ] **의존성**: 알려진 보안 취약점 없음
- [ ] **성능**: 성능 회귀 없음
- [ ] **메모리**: 메모리 누수나 리소스 문제 없음
- [ ] **에러 처리**: 적절한 에러 처리 구현됨

**문서화**:

- [ ] **코드 주석**: 복잡한 로직 문서화됨
- [ ] **API 문서**: 공개 인터페이스 문서화됨
- [ ] **README**: 필요 시 사용 지침 업데이트됨

**수동 테스트**:

- [ ] **기능성**: 기능이 예상대로 작동함
- [ ] **엣지 케이스**: 경계 조건 테스트됨
- [ ] **에러 상태**: 에러 처리 검증됨

**검증 명령어**:

```bash
[이전 단계와 동일 - 프로젝트에 맞게 커스터마이징]
```

**수동 테스트 체크리스트**:

- [ ] 테스트 케이스 1: [검증할 구체적인 시나리오]
- [ ] 테스트 케이스 2: [검증할 엣지 케이스]
- [ ] 테스트 케이스 3: [검증할 에러 처리]

---

### 단계 3: [개선 단계명]

**목표**: [구체적인 산출물]
**예상 시간**: X 시간
**상태**: ⏳ 대기 | 🔄 진행 중 | ✅ 완료

#### 작업

**🔴 RED: 실패하는 테스트 먼저 작성**

- [ ] **Test 3.1**: [구체적인 기능]에 대한 단위 테스트 작성
  - 파일: `test/unit/[feature]/[component]_test.*`
  - 예상: 기능이 아직 없으므로 테스트 실패 (Red)
  - 상세: 다음을 커버하는 테스트 케이스:
    - 해피 패스 시나리오
    - 엣지 케이스
    - 에러 조건

- [ ] **Test 3.2**: [컴포넌트 상호작용]에 대한 통합 테스트 작성
  - 파일: `test/integration/[feature]_test.*`
  - 예상: 통합이 아직 없으므로 테스트 실패 (Red)
  - 상세: [컴포넌트 목록] 간의 상호작용 테스트

**🟢 GREEN: 테스트를 통과시키기 위한 구현**

- [ ] **Task 3.3**: [컴포넌트/모듈] 구현
  - 파일: `src/[layer]/[component].*`
  - 목표: 최소한의 코드로 Test 3.1 통과
  - 상세: [구현 노트]

- [ ] **Task 3.4**: [통합/글루 코드] 구현
  - 파일: `src/[layer]/[integration].*`
  - 목표: Test 3.2 통과
  - 상세: [구현 노트]

**🔵 REFACTOR: 코드 정리**

- [ ] **Task 3.5**: 코드 품질을 위한 리팩터링
  - 파일: 이 단계의 모든 새 코드 검토
  - 목표: 테스트를 깨뜨리지 않고 설계 개선
  - 체크리스트:
    - [ ] 중복 제거 (DRY 원칙)
    - [ ] 네이밍 명확성 개선
    - [ ] 재사용 가능한 컴포넌트 추출
    - [ ] 인라인 문서 추가
    - [ ] 필요 시 성능 최적화

#### 품질 게이트 ✋

**⚠️ STOP: 모든 항목이 통과할 때까지 진행하지 마세요**

**TDD 준수** (중요):

- [ ] **Red 단계**: 테스트를 먼저 작성했고 초기에 실패했음
- [ ] **Green 단계**: 테스트를 통과시키기 위해 프로덕션 코드를 작성했음
- [ ] **Refactor 단계**: 테스트가 통과하는 상태에서 코드를 개선했음
- [ ] **커버리지 확인**: 테스트 커버리지가 요구사항을 충족함

**빌드 및 테스트**:

- [ ] **빌드**: 프로젝트가 오류 없이 빌드/컴파일됨
- [ ] **모든 테스트 통과**: 100% 테스트 통과 (건너뛴 테스트 없음)
- [ ] **테스트 성능**: 테스트 스위트가 허용 가능한 시간 내에 완료됨
- [ ] **플래키 테스트 없음**: 테스트가 일관되게 통과함 (3회 이상 실행)

**코드 품질**:

- [ ] **린팅**: 린팅 오류나 경고 없음
- [ ] **포맷팅**: 프로젝트 표준에 따라 코드 포맷팅됨
- [ ] **타입 안전성**: 타입 체커 통과 (해당되는 경우)
- [ ] **정적 분석**: 정적 분석 도구에서 중요 이슈 없음

**보안 및 성능**:

- [ ] **의존성**: 알려진 보안 취약점 없음
- [ ] **성능**: 성능 회귀 없음
- [ ] **메모리**: 메모리 누수나 리소스 문제 없음
- [ ] **에러 처리**: 적절한 에러 처리 구현됨

**문서화**:

- [ ] **코드 주석**: 복잡한 로직 문서화됨
- [ ] **API 문서**: 공개 인터페이스 문서화됨
- [ ] **README**: 필요 시 사용 지침 업데이트됨

**수동 테스트**:

- [ ] **기능성**: 기능이 예상대로 작동함
- [ ] **엣지 케이스**: 경계 조건 테스트됨
- [ ] **에러 상태**: 에러 처리 검증됨

**검증 명령어**:

```bash
[이전 단계와 동일 - 프로젝트에 맞게 커스터마이징]
```

**수동 테스트 체크리스트**:

- [ ] 테스트 케이스 1: [검증할 구체적인 시나리오]
- [ ] 테스트 케이스 2: [검증할 엣지 케이스]
- [ ] 테스트 케이스 3: [검증할 에러 처리]

---

## ⚠️ 위험 평가

| 위험 | 확률 | 영향 | 완화 전략 |
|------|------|------|-----------|
| [위험 1: 예: API 변경으로 인한 통합 깨짐] | 낮음/중/높음 | 낮음/중/높음 | [구체적인 완화 조치] |
| [위험 2: 예: 성능 저하] | 낮음/중/높음 | 낮음/중/높음 | [구체적인 완화 조치] |
| [위험 3: 예: 데이터베이스 마이그레이션 이슈] | 낮음/중/높음 | 낮음/중/높음 | [구체적인 완화 조치] |

---

## 🔄 롤백 전략

### 단계 1 실패 시

**되돌리기 단계**:

- 다음 파일의 코드 변경 취소: [파일 목록]
- 설정 복구: [구체적인 설정]
- 의존성 제거: [추가된 것이 있다면]

### 단계 2 실패 시

**되돌리기 단계**:

- 단계 1 완료 상태로 복구
- 다음 파일의 변경 취소: [파일 목록]
- 데이터베이스 롤백: [해당되는 경우]

### 단계 3 실패 시

**되돌리기 단계**:

- 단계 2 완료 상태로 복구
- [추가 정리 단계]

---

## 📊 진척도 추적

### 완료 상태

- **단계 1**: ⏳ 0% | 🔄 50% | ✅ 100%
- **단계 2**: ⏳ 0% | 🔄 50% | ✅ 100%
- **단계 3**: ⏳ 0% | 🔄 50% | ✅ 100%

**전체 진척도**: X% 완료

### 시간 추적

| 단계 | 예상 | 실제 | 차이 |
|------|------|------|------|
| 단계 1 | X 시간 | Y 시간 | +/- Z 시간 |
| 단계 2 | X 시간 | - | - |
| 단계 3 | X 시간 | - | - |
| **합계** | X 시간 | Y 시간 | +/- Z 시간 |

---

## 📝 참고 및 교훈

### 구현 노트

- [구현 중 발견한 인사이트 추가]
- [원래 계획에서 벗어난 결정사항 문서화]
- [도움이 된 디버깅 발견사항 기록]

### 발생한 블로커

- **블로커 1**: [설명] → [해결]
- **블로커 2**: [설명] → [해결]

### 향후 계획을 위한 개선점

- [다음에 다르게 할 점은 무엇인가?]
- [특별히 잘 된 점은 무엇인가?]

---

## 📚 참조

### 문서

- [관련 문서 링크]
- [API 참조 링크]
- [디자인 목업 링크]

### 관련 이슈

- Issue #X: [설명]
- PR #Y: [설명]

---

## ✅ 최종 체크리스트

**계획을 완료로 표시하기 전**:

- [ ] 모든 단계가 완료되고 품질 게이트 통과됨
- [ ] 전체 통합 테스트 수행됨
- [ ] 문서 업데이트됨
- [ ] 성능 벤치마크가 목표 충족함
- [ ] 보안 검토 완료됨
- [ ] 접근성 요구사항 충족됨 (UI 기능인 경우)
- [ ] 모든 이해관계자에게 알림
- [ ] 향후 참조를 위해 계획 문서 아카이브됨

---

## 📖 TDD 예시 워크플로우

### 예시: 사용자 인증 기능 추가

**단계 1: RED (실패하는 테스트 작성)**

```
# 의사코드(Pseudocode) - 테스트 프레임워크에 맞게 조정

test "사용자 자격증명을 검증해야 함":
  // Arrange
  authService = new AuthService(mockDatabase)
  validCredentials = {username: "user", password: "pass"}

  // Act
  result = authService.authenticate(validCredentials)

  // Assert
  expect(result.isSuccess).toBe(true)
  expect(result.user).toBeDefined()
  // 테스트 실패 - AuthService가 아직 존재하지 않음
```

**단계 2: GREEN (최소 구현)**

```
class AuthService:
  function authenticate(credentials):
    // 테스트를 통과시키기 위한 최소한의 코드
    user = database.findUser(credentials.username)
    if user AND user.password == credentials.password:
      return Success(user)
    return Failure("Invalid credentials")
    // 테스트 통과 - 최소 기능 작동
```

**단계 3: REFACTOR (설계 개선)**

```
class AuthService:
  function authenticate(credentials):
    // 유효성 검사 추가
    if not this.validateCredentials(credentials):
      return Failure("Invalid input")

    // 에러 처리 추가
    try:
      user = database.findUser(credentials.username)

      // 보안 비밀번호 비교 사용
      if user AND this.secureCompare(user.password, credentials.password):
        return Success(user)

      return Failure("Invalid credentials")
    catch DatabaseError as error:
      logger.error(error)
      return Failure("Authentication failed")
    // 테스트 여전히 통과 - 코드 품질 향상됨
```

### TDD Red-Green-Refactor 사이클 시각화

```
단계 1: 🔴 RED
├── 기능 X에 대한 테스트 작성
├── 테스트 실행 → 실패 ❌
└── 커밋: "X에 대한 실패하는 테스트 추가"

단계 2: 🟢 GREEN
├── 최소한의 코드 작성
├── 테스트 실행 → 통과 ✅
└── 커밋: "테스트 통과를 위해 X 구현"

단계 3: 🔵 REFACTOR
├── 코드 품질 개선
├── 테스트 실행 → 여전히 통과 ✅
├── 헬퍼 메서드 추출
├── 테스트 실행 → 여전히 통과 ✅
├── 네이밍 개선
├── 테스트 실행 → 여전히 통과 ✅
└── 커밋: "더 나은 설계를 위해 X 리팩터링"

다음 기능으로 반복 →
```

### 이 접근 방식의 장점

**안전성**: 테스트가 회귀를 즉시 잡아냄
**설계**: 테스트가 API 설계를 먼저 생각하게 강제함
**문서화**: 테스트가 예상 동작을 문서화함
**자신감**: 무언가 깨뜨릴 두려움 없이 리팩터링 가능
**품질**: 첫날부터 높은 코드 커버리지
**디버깅**: 실패가 정확한 문제 영역을 가리킴
