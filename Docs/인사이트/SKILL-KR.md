---
name: feature-planner
description: 품질 게이트와 점진적 배포 구조를 갖춘 단계별 기능 계획을 생성합니다. 기능 기획, 업무 정리, 작업 세분화, 로드맵 작성 또는 개발 전략 수립 시 사용하세요. 키워드: 계획, 기획, 단계, 세분화, 전략, 로드맵, 정리, 구조, 개요.
---

# 기능 기획자 (Feature Planner)

## 목적

다음과 같은 구조화된 단계별 계획을 생성합니다:

- 각 단계는 실행 가능한 완전한 기능을 제공
- 다음 단계로 넘어가기 전 품질 게이트를 통해 검증 강제
- 작업 시작 전 사용자의 계획 승인 필수
- 마크다운 체크박스를 통한 진척도 추적
- 각 단계는 최대 1-4시간 소요

## 기획 워크플로우

### 단계 1: 요구사항 분석

1. 관련 파일을 읽어 코드베이스 아키텍처 이해
2. 의존성 및 통합 포인트 식별
3. 복잡도 및 위험 요소 평가
4. 적절한 범위 결정 (소/중/대)

### 단계 2: TDD 통합을 포함한 단계별 세분화

기능을 3-7단계로 나누며 각 단계는 다음을 따름:

- **테스트 우선 (Test-First)**: 구현 전 테스트 작성
- 작동하고 테스트 가능한 기능 제공
- 최대 1-4시간 소요
- Red-Green-Refactor 사이클 준수
- 측정 가능한 테스트 커버리지 요구사항 포함
- 독립적으로 롤백 가능
- 명확한 성공 기준 보유

**단계 구조**:

- 단계명: 명확한 산출물
- 목표: 이 단계에서 생성되는 작동하는 기능
- **테스트 전략**: 테스트 유형, 커버리지 목표, 테스트 시나리오
- 작업 (TDD 워크플로우 순서):
  1. **RED 작업**: 실패하는 테스트 먼저 작성
  2. **GREEN 작업**: 테스트를 통과시키는 최소한의 코드 구현
  3. **REFACTOR 작업**: 테스트 통과 상태를 유지하며 코드 품질 개선
- 품질 게이트: TDD 준수 여부 + 검증 기준
- 의존성: 시작 전 존재해야 하는 것
- **커버리지 목표**: 해당 단계의 구체적인 퍼센트 또는 체크리스트

### 단계 3: 계획 문서 작성

`plan-template-KR.md`를 사용하여 다음을 생성: `docs/plans/PLAN_<기능명>.md`

포함 내용:

- 개요 및 목표
- 근거가 포함된 아키텍처 결정사항
- 체크박스가 포함된 전체 단계 세분화
- 품질 게이트 체크리스트
- 위험 평가 테이블
- 단계별 롤백 전략
- 진척도 추적 섹션
- 참고 및 교훈 영역

### 단계 4: 사용자 승인

**중요**: `AskUserQuestion`을 사용하여 진행 전 명시적인 승인을 받으세요.

질문:

- "이 단계별 세분화가 프로젝트에 적합한가요?"
- "제안된 접근 방식에 우려되는 점이 있나요?"
- "계획 문서 작성을 진행해도 될까요?"

사용자가 승인을 확인한 후에만 계획 문서를 생성하세요.

### 단계 5: 문서 생성

1. `docs/plans/` 디렉토리가 없으면 생성
2. 모든 체크박스가 해제된 상태로 계획 문서 생성
3. 헤더에 품질 게이트에 대한 명확한 지침 추가
4. 사용자에게 계획 문서 위치 및 다음 단계 알림

## 품질 게이트 기준

각 단계는 다음 항목을 검증한 후에만 다음 단계로 진행해야 합니다:

**빌드 및 컴파일**:

- [ ] 프로젝트가 오류 없이 빌드/컴파일됨
- [ ] 문법 오류 없음

**테스트 주도 개발 (TDD)**:

- [ ] 프로덕션 코드보다 테스트를 먼저 작성함
- [ ] Red-Green-Refactor 사이클을 준수함
- [ ] 단위 테스트: 비즈니스 로직에 대해 80% 이상 커버리지
- [ ] 통합 테스트: 핵심 사용자 흐름 검증됨
- [ ] 테스트 스위트가 허용 가능한 시간(<5분) 내에 실행됨

**테스트**:

- [ ] 모든 기존 테스트 통과
- [ ] 새로운 기능에 대한 새로운 테스트 추가됨
- [ ] 테스트 커버리지가 유지되거나 향상됨

**코드 품질**:

- [ ] 린팅(Linting)이 오류 없이 통과
- [ ] 타입 체크 통과 (해당되는 경우)
- [ ] 코드 포맷팅 일관성 유지

**기능성**:

- [ ] 수동 테스트로 기능 작동 확인
- [ ] 기존 기능에 회귀(Regression) 없음
- [ ] 엣지 케이스 테스트됨

**보안 및 성능**:

- [ ] 새로운 보안 취약점 없음
- [ ] 성능 저하 없음
- [ ] 리소스 사용량 허용 범위 내

**문서화**:

- [ ] 코드 주석 업데이트됨
- [ ] 변경 사항이 문서에 반영됨

## 진척도 추적 프로토콜

계획 문서 헤더에 다음을 추가하세요:

```markdown
**중요 지침**: 각 단계를 완료한 후:
1. ✅ 완료된 작업 체크박스 체크
2. 🧪 모든 품질 게이트 검증 명령어 실행
3. ⚠️ 모든 품질 게이트 항목이 통과하는지 확인
4. 📅 "최종 수정일" 업데이트
5. 📝 참고 섹션에 교훈 기록
6. ➡️ 그 후에만 다음 단계로 진행

⛔ 품질 게이트를 건너뛰거나 실패한 항목이 있는 상태로 진행하지 마세요
```

## 단계 크기 산정 가이드라인

**작은 범위** (2-3 단계, 총 3-6시간):

- 단일 컴포넌트 또는 단순 기능
- 최소한의 의존성
- 명확한 요구사항
- 예: 다크 모드 토글 추가, 새 폼 컴포넌트 생성

**중간 범위** (4-5 단계, 총 8-15시간):

- 다수 컴포넌트 또는 중간 규모 기능
- 약간의 통합 복잡성
- 데이터베이스 변경 또는 API 작업
- 예: 사용자 인증 시스템, 검색 기능

**큰 범위** (6-7 단계, 총 15-25시간):

- 여러 영역에 걸친 복잡한 기능
- 상당한 아키텍처 영향
- 다중 통합
- 예: 임베딩을 이용한 AI 검색, 실시간 협업

## 위험 평가

다음 사항을 식별하고 문서화하세요:

- **기술적 위험**: API 변경, 성능 이슈, 데이터 마이그레이션
- **의존성 위험**: 외부 라이브러리 업데이트, 서드파티 서비스 가용성
- **일정 위험**: 복잡도 미지수, 블로킹 의존성
- **품질 위험**: 테스트 커버리지 공백, 회귀 가능성

각 위험에 대해 명시:

- 확률: 낮음/중간/높음
- 영향: 낮음/중간/높음
- 완화 전략: 구체적인 조치 단계

## 롤백 전략

각 단계에 대해 문제 발생 시 변경 사항을 되돌리는 방법을 문서화하세요.
고려사항:

- 어떤 코드 변경을 취소해야 하는지
- 되돌려야 할 데이터베이스 마이그레이션 (해당되는 경우)
- 복구해야 할 설정 변경
- 제거해야 할 의존성

## 테스트 명세 가이드라인

### 테스트 우선 개발 워크플로우

**각 기능 컴포넌트별**:

1. **테스트 케이스 명세** (코드 작성 전)
   - 어떤 입력을 테스트할 것인가?
   - 어떤 출력이 예상되는가?
   - 어떤 엣지 케이스를 처리해야 하는가?
   - 어떤 에러 조건을 테스트해야 하는가?

2. **테스트 작성** (Red 단계)
   - 실패할 테스트 작성
   - 테스트가 올바른 이유로 실패하는지 확인
   - 테스트를 실행하여 실패 확인
   - TDD 준수 추적을 위해 실패하는 테스트 커밋

3. **코드 구현** (Green 단계)
   - 테스트를 통과시키기 위한 최소한의 코드 작성
   - 테스트 자주 실행 (2-5분마다)
   - 모든 테스트가 통과하면 중단
   - 테스트 범위를 벗어나는 추가 기능 구현 금지

4. **리팩터링** (Blue 단계)
   - 테스트가 통과하는 상태에서 코드 품질 개선
   - 중복 로직 추출
   - 네이밍 및 구조 개선
   - 각 리팩터링 단계 후 테스트 실행
   - 리팩터링 완료 후 커밋

### 테스트 유형

**단위 테스트 (Unit Tests)**:

- **대상**: 개별 함수, 메서드, 클래스
- **의존성**: 없음 또는 모의(mock)/스텁(stub) 처리
- **속도**: 빠름 (테스트당 <100ms)
- **격리**: 외부 시스템으로부터 완전 격리
- **커버리지**: 비즈니스 로직의 80% 이상

**통합 테스트 (Integration Tests)**:

- **대상**: 컴포넌트/모듈 간의 상호작용
- **의존성**: 실제 의존성 사용 가능
- **속도**: 보통 (테스트당 <1s)
- **격리**: 컴포넌트 경계 테스트
- **커버리지**: 핵심 통합 포인트

**E2E 테스트 (End-to-End Tests)**:

- **대상**: 전체 사용자 워크플로우
- **의존성**: 실제 또는 실제에 가까운 환경
- **속도**: 느림 (수 초에서 수 분)
- **격리**: 전체 시스템 통합
- **커버리지**: 핵심 사용자 여정

### 테스트 커버리지 산정

**커버리지 임계값** (프로젝트에 맞게 조정):

- **비즈니스 로직**: 90% 이상 (핵심 코드 경로)
- **데이터 접근 계층**: 80% 이상 (리포지토리, DAO)
- **API/컨트롤러 계층**: 70% 이상 (엔드포인트)
- **UI/프레젠테이션**: 커버리지보다 통합 테스트 선호

**생태계별 커버리지 명령어**:

```bash
# JavaScript/TypeScript
jest --coverage
nyc report --reporter=html

# Python
pytest --cov=src --cov-report=html
coverage report

# Java
mvn jacoco:report
gradle jacocoTestReport

# Go
go test -cover ./...
go tool cover -html=coverage.out

# .NET
dotnet test /p:CollectCoverage=true /p:CoverageReporter=html
reportgenerator -reports:coverage.xml -targetdir:coverage

# Ruby
bundle exec rspec --coverage
open coverage/index.html

# PHP
phpunit --coverage-html coverage
```

### 일반적인 테스트 패턴

**Arrange-Act-Assert (AAA) 패턴**:

```
test '동작에 대한 설명':
  // Arrange: 테스트 데이터 및 의존성 설정
  input = createTestData()

  // Act: 테스트할 동작 실행
  result = systemUnderTest.method(input)

  // Assert: 예상 결과 검증
  assert result == expectedOutput
```

**Given-When-Then (BDD 스타일)**:

```
test '기능이 특정 방식으로 동작해야 함':
  // Given: 초기 상황/상태
  given userIsLoggedIn()

  // When: 액션 발생
  when userClicksButton()

  // Then: 관찰 가능한 결과
  then shouldSeeConfirmation()
```

**의존성 모의(Mocking)/스텁(Stubbing)**:

```
test '컴포넌트가 의존성을 호출해야 함':
  // 모의/스텁 생성
  mockService = createMock(ExternalService)
  component = new Component(mockService)

  // 모의 동작 설정
  when(mockService.method()).thenReturn(expectedData)

  // 실행 및 검증
  component.execute()
  verify(mockService.method()).calledOnce()
```

### 계획 문서 내 테스트 명세

**각 단계별 명세 항목**:

1. **테스트 파일 위치**: 테스트가 작성될 정확한 경로
2. **테스트 시나리오**: 구체적인 테스트 케이스 목록
3. **예상되는 실패**: 초기에 테스트가 어떤 에러를 보여야 하는가?
4. **커버리지 목표**: 해당 단계의 퍼센트
5. **모의(Mock)할 의존성**: 무엇을 모의/스텁 처리해야 하는가?
6. **테스트 데이터**: 어떤 픽스처/팩토리가 필요한가?

## 참조 파일

- [plan-template-KR.md](plan-template-KR.md) - 전체 계획 문서 템플릿
